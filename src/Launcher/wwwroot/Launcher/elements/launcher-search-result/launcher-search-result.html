<link rel="import" href="/sys/polymer/polymer.html" />

<dom-module id="launcher-search-result">
    <style>
        :host {
            color: black;
        }
        .typeheader {
          padding: 2px;
          margin-bottom: 5px;
          background-color: antiquewhite;
          display: flex;
        }
        .item {
          padding: 4px;
          background-color: #eee;
          padding: 3px;
          background-color: #eee;
          margin: 5px;
        }
    </style>
    <template>
      <template is="dom-repeat" items="{{types}}" as="type">
        <div class="typeheader"><span style="flex:1">{{type.Type}}</span>(<span>{{type.Count}}</span>)</div>
        <div class="items">
          <template is="dom-repeat" items="{{type.Items}}" as="item">
            <div class="item" on-mouseover="suggestionHovered">
              <template is="imported-template" model="{{item}}" content$="{{item.Html}}"></template>
            </div>
          </template>
        </div>
      </template>
    </template>
    <script>
        Polymer({
            is: 'launcher-search-result',
            properties: {
                data: {
                    notify: true,
                },
                types: {
                  type: Array,
                  value: [],
                }
            },
  		      observers: [
  			      'resultChanged(data.*)'
  		      ],
            ready: function () {
                this.data = this.data || {};
            },
            suggestionHovered: function (event, detail) {
              removeClass(Polymer.dom(this).querySelector('div.active'), 'active');
              addClass(event.currentTarget, 'active');
            },
            resultChanged: function (d) {
              var types = [];
              for (var name in this.data)
              {
                if (this.data.hasOwnProperty(name) && this.data[name].hasOwnProperty("Types")) {
                  for (var i = 0; i < this.data[name].Types.length; i++) {
                    types.push(this.data[name].Types[i]);
                  }
                }
              }
              this.set('types', types);
              console.log(types);
            },
            suggestionTapped: function (event, detail, sender) {
  			         var data = event.model;
                if (data && data.item.Action) {
                    this.set('data.Action$', data.item.Action);
                }
                this.resetSearch();
            },
            resetSearch: function () {
                this.set('data.SearchString$', '');
                this.$.overlay.close();
            },
            suggestionHovered: function (event, detail, sender) {
                this.setActive(event.model.item);
            },
            setActive: function (item) {
                if (this.active) {
                    this.set('active._active', false);
                }
                this.active = item;
                if (item) {
                    item._active = true;
                }
            },
            activateLast: function () {
                var count = this.data.Result.length;
                if (count > 0)
                    this.setActive(this.data.Result[count - 1]);
            },
            activateFirst: function () {
                var count = this.data.Result.length;
                if (count > 0)
                    this.setActive(this.data.Result[0]);
            },
            activateNext: function () {
                if (this.active) {
                    for (var i = 0; i < this.data.Result.length; i++) {
                        if (this.data.Result[i] == this.active) {
                            if (this.data.Result.length > i + 1) {
                                this.setActive(this.data.Result[i + 1]);
                            } else
                                this.activateFirst();
                            return;
                        }
                    }
                }
                this.activateFirst();
            },
            activatePrevious: function () {
                if (this.active) {
                    for (var i = 0; i < this.data.Result.length; i++) {
                        if (this.data.Result[i] == this.active) {
                            if (i > 0) {
                                this.setActive(this.data.Result[i - 1]);
                            } else
                                this.activateLast();
                            return;
                        }
                    }
                }
                this.activateLast();
            },
            keydownHandler: function (event, detail, sender) {
                switch (event.keyCode) {
                    case 38:
                        // up arrow
                        this.activatePrevious();
                        break;
                    case 40:
                        // down arrow
                        this.activateNext();
                        break;
                    case 13:
                        // enter
                        if (this.active && this.active.Action) {
                            this.set('data.Action$', this.active.Action);
                            this.resetSearch();
                        }
                        break;
                }
                ;
            },
            //debugger;
            focus: function () {
                this.$.input.focus();
            },
            /*
            _computeClass: function (active) {
                return active ? 'active' : '';
            },
            _getTypes = function(data) {
              var items = [];
              for (var name in data)
              {
                if (data.hasOwnProperty(name) && data[name].hasOwnProperty("Types")) {
                   for (var i = 0; i < data[name].Types.length; i++) {
                     items.push(data[name].Items[i]);
                   }
                }
              }
              return items;
            }*/
        });
    </script>
</dom-module>
